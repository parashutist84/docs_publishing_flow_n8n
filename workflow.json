{
  "name": "My workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "61193a00-dce7-4d57-bc8c-75789846daae",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        0,
        0
      ],
      "id": "7874b596-5b8d-48dc-983b-932addd787f7",
      "name": "Webhook",
      "webhookId": "61193a00-dce7-4d57-bc8c-75789846daae"
    },
    {
      "parameters": {
        "authentication": "serviceAccount",
        "operation": "get",
        "documentURL": "={{ $json.body.docId }}",
        "simple": false
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        176,
        0
      ],
      "id": "1867da97-ee1e-44a8-bd8b-eee76f5f59ef",
      "name": "Get a document",
      "credentials": {
        "googleApi": {
          "id": "q0RH8mKgQAahSr1L",
          "name": "Google Service Account account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1040,
        176
      ],
      "id": "013c3d30-c129-4d8b-a6be-beee44fbb84b",
      "name": "Loop Over Items"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1280,
        16
      ],
      "id": "1f711019-368a-4c8f-ba62-fa892fa7b3fd",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "console.log($node['Convert Google DOCS to HTML'].json)\nconst converterResult = $node['Convert Google DOCS to HTML'].json;\n\nconst html = converterResult.htmlWordPress;\nconst images = converterResult.images || [];\n\nreturn images\n  .filter(image => !image.omit_upload)\n  .map((image, index) => ({\n  id: image.id,\n  contentUri: image.contentUri,\n  alt: image.alt,\n  title: image.title,\n  \n  fileName: (() => {\n    const baseName = image.title || image.alt || `image-${image.id}`;\n    \n    let extension = '.jpg';\n    if (image.contentUri) {\n      const url = image.contentUri.toLowerCase();\n      if (url.includes('.png') || url.includes('png')) extension = '.png';\n      else if (url.includes('.gif') || url.includes('gif')) extension = '.gif';\n      else if (url.includes('.webp') || url.includes('webp')) extension = '.webp';\n      else if (url.includes('.svg') || url.includes('svg')) extension = '.svg';\n      else if (url.includes('.bmp') || url.includes('bmp')) extension = '.bmp';\n    }\n\n    const cleanName = baseName\n      .replace(/[^\\w\\s\\-]/g, '')\n      .replace(/\\s+/g, ' ')\n      .trim()\n      .replace(/\\s/g, '-')\n      .replace(/\\-+/g, '-')\n      .replace(/^-|-$/g, '')\n      .substring(0, 95)\n      .toLowerCase();\n    \n    return cleanName + extension;\n  })()\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        832,
        176
      ],
      "id": "2dd4ed04-6d52-4b77-922a-463630a6533c",
      "name": "Prepare images metadata"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Google Docs to HTML Converter for n8n\n * \n * USAGE INSTRUCTIONS FOR n8n:\n * \n * 1. Create a Code Node (Function Item)\n * 2. Copy this entire code into the JavaScript Code field\n * 3. At the end of the code add:\n *    \n *    const html = convertGoogleDocsToHtml($json.body);\n *    return { html: html };\n * \n * 4. Where $json.body is the document structure from Google Docs API\n */\n\nfunction convertGoogleDocsToHtml(docStructure, documentLists = null, inlineObjects = null) {\n    let html = '';\n    let currentListId = null;\n    let openListTags = [];\n    let currentNestingLevel = -1;\n    let images = []; // Collect images during processing\n\n    // RGB color processing\n    function rgbToHex(rgb) {\n        if (!rgb || typeof rgb !== 'object') return null;\n        const r = Math.round((rgb.red || 0) * 255);\n        const g = Math.round((rgb.green || 0) * 255);\n        const b = Math.round((rgb.blue || 0) * 255);\n        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n    }\n\n    // HTML escaping\n    function escapeHtml(text) {\n        const map = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#039;'\n        };\n        return text.replace(/[&<>\"']/g, function(m) { return map[m]; });\n    }\n\n    // Safe string conversion (solves [object Object] problem)\n    function safeToString(value) {\n        if (typeof value === 'string') {\n            return value;\n        }\n        if (value === null || value === undefined) {\n            return '';\n        }\n        if (typeof value === 'object') {\n            // If it's an object, try to get meaningful representation\n            if (value.toString && typeof value.toString === 'function' && value.toString !== Object.prototype.toString) {\n                return value.toString();\n            }\n            // As last resort return empty string instead of [object Object]\n            return '';\n        }\n        return String(value);\n    }\n\n    // Apply text styles\n    function applyTextStyles(content, textStyle) {\n        if (!textStyle) return escapeHtml(content);\n        \n        let styledContent = escapeHtml(content);\n        let styles = [];\n        let tags = [];\n\n        // Bold text\n        if (textStyle.bold) {\n            tags.push('strong');\n        }\n\n        // Italic\n        if (textStyle.italic) {\n            tags.push('em');\n        }\n\n        // Underline\n        if (textStyle.underline) {\n            tags.push('u');\n        }\n\n        // Strikethrough text\n        if (textStyle.strikethrough) {\n            tags.push('s');\n        }\n\n        // Text color\n        if (textStyle.foregroundColor?.color?.rgbColor) {\n            const color = rgbToHex(textStyle.foregroundColor.color.rgbColor);\n            if (color && color !== '#000000') {\n                styles.push(`color: ${color}`);\n            }\n        }\n\n        // Background color\n        if (textStyle.backgroundColor?.color?.rgbColor) {\n            const bgColor = rgbToHex(textStyle.backgroundColor.color.rgbColor);\n            if (bgColor && bgColor !== '#ffffff') {\n                styles.push(`background-color: ${bgColor}`);\n            }\n        }\n\n        // Font size\n        if (textStyle.fontSize?.magnitude) {\n            styles.push(`font-size: ${textStyle.fontSize.magnitude}pt`);\n        }\n\n        // Font family\n        if (textStyle.weightedFontFamily?.fontFamily) {\n            styles.push(`font-family: \"${textStyle.weightedFontFamily.fontFamily}\"`);\n        }\n\n        // Wrap in tags\n        for (const tag of tags) {\n            styledContent = `<${tag}>${styledContent}</${tag}>`;\n        }\n\n        // Apply inline styles\n        if (styles.length > 0) {\n            styledContent = `<span style=\"${styles.join('; ')}\">${styledContent}</span>`;\n        }\n\n        return styledContent;\n    }\n\n    // Link processing\n    function processLink(content, textStyle) {\n        if (textStyle?.link?.url) {\n            const styledContent = applyTextStyles(content, {...textStyle, link: undefined});\n            return `<a href=\"${escapeHtml(textStyle.link.url)}\" target=\"_blank\">${styledContent}</a>`;\n        }\n        return applyTextStyles(content, textStyle);\n    }\n\n    // Process paragraph elements\n    function processTextElements(elements) {\n        let result = '';\n        \n        for (const element of elements) {\n            if (element.textRun) {\n                let content = element.textRun.content;\n                \n                // Process line breaks - remove trailing newlines\n                while (content.endsWith('\\n') || content.endsWith('\\\\n')) {\n                    if (content.endsWith('\\\\n')) {\n                        content = content.slice(0, -2);\n                    } else if (content.endsWith('\\n')) {\n                        content = content.slice(0, -1);\n                    }\n                }\n                \n                if (content) {\n                    // First apply text styles (which will escape HTML)\n                    const linkResult = processLink(content, element.textRun.textStyle);\n                    // Then replace newlines with <br> (after escaping)\n                    const processedResult = safeToString(linkResult)\n                        .replace(/\\\\n/g, '<br>')\n                        .replace(/\\n/g, '<br>');\n                    result += processedResult;\n                }\n            } else if (element.inlineObjectElement) {\n                // Process inline objects (images, etc.) - create placeholder\n                const inlineObjectId = element.inlineObjectElement.inlineObjectId;\n                \n                // Get image data from inlineObjects if available\n                let altText = '';\n                let contentUri = '';\n                if (inlineObjects && inlineObjects[inlineObjectId]) {\n                    const embeddedObject = inlineObjects[inlineObjectId].inlineObjectProperties?.embeddedObject;\n                    if (embeddedObject) {\n                        altText = embeddedObject.description || embeddedObject.title || '';\n                        contentUri = embeddedObject.imageProperties?.contentUri || '';\n                        \n                        // Check if this is an icon (contains [icon] marker)\n                        let omitUpload = false;\n                        if (altText.includes('[icon]')) {\n                            omitUpload = true;\n                            altText = altText.replace(/\\[icon\\]/g, '').trim();\n                        }\n                        \n                        // Add to images array if it's actually an image\n                        if (contentUri) {\n                            images.push({\n                                id: inlineObjectId,\n                                contentUri: contentUri,\n                                alt: altText,\n                                title: embeddedObject.title || '',\n                                omit_upload: omitUpload\n                            });\n                        }\n                    }\n                }\n                \n                // Create image placeholder\n                result += `[[IMG:${inlineObjectId}|${altText}]]`;\n            }\n        }\n        \n        return result;\n    }\n\n    // List processing with multi-level support\n    function handleList(paragraph) {\n        const bullet = paragraph.bullet;\n        if (!bullet) return null;\n\n        const listId = bullet.listId;\n        const nestingLevel = bullet.nestingLevel || 0;\n        \n        // Handle different list or different nesting level\n        if (currentListId !== listId || currentNestingLevel !== nestingLevel) {\n            \n            // If it's a completely different list, close all open lists\n            if (currentListId !== listId) {\n                while (openListTags.length > 0) {\n                    html += `</${openListTags.pop()}>`;\n                }\n                currentNestingLevel = -1;\n            }\n            \n            // Handle nesting level changes\n            if (nestingLevel > currentNestingLevel) {\n                // Going deeper - open new nested lists\n                while (currentNestingLevel < nestingLevel) {\n                    currentNestingLevel++;\n                    const listTag = getListType(listId, documentLists, currentNestingLevel);\n                    html += `<${listTag}>`;\n                    openListTags.push(listTag);\n                }\n            } else if (nestingLevel < currentNestingLevel) {\n                // Going up - close nested lists\n                while (currentNestingLevel > nestingLevel) {\n                    if (openListTags.length > 0) {\n                        html += `</${openListTags.pop()}>`;\n                    }\n                    currentNestingLevel--;\n                }\n            }\n            \n            currentListId = listId;\n            currentNestingLevel = nestingLevel;\n        }\n\n        return true;\n    }\n\n    // Determine if list is numbered (ol) or bulleted (ul) based on nesting level\n    function getListType(listId, lists, level = 0) {\n        if (!lists || !lists[listId]) {\n            return 'ul'; // Default to bulleted list\n        }\n        \n        const listProperties = lists[listId].listProperties;\n        if (!listProperties || !listProperties.nestingLevels) {\n            return 'ul';\n        }\n        \n        // Get the appropriate nesting level, fallback to level 0 if specific level not found\n        const nestingLevelIndex = Math.min(level, listProperties.nestingLevels.length - 1);\n        const nestingLevel = listProperties.nestingLevels[nestingLevelIndex];\n        \n        if (!nestingLevel) {\n            return 'ul';\n        }\n        \n        // Check for glyph symbol first - if present, it's always bulleted\n        if (nestingLevel.glyphSymbol) {\n            return 'ul';\n        }\n        \n        // Check glyphType - this is the most reliable indicator for numbered lists\n        if (nestingLevel.glyphType) {\n            switch (nestingLevel.glyphType) {\n                case 'DECIMAL':\n                case 'ZERO_DECIMAL':\n                case 'ALPHA':\n                case 'UPPER_ALPHA':\n                case 'ROMAN':\n                case 'UPPER_ROMAN':\n                    return 'ol';\n                case 'GLYPH_TYPE_UNSPECIFIED':\n                    return 'ul'; // Always bulleted for unspecified type\n                default:\n                    break;\n            }\n        }\n        \n        return 'ul'; // Default to bulleted\n    }\n\n    // Determine heading type\n    function getHeadingTag(namedStyleType) {\n        switch (namedStyleType) {\n            case 'HEADING_1': return 'h1';\n            case 'HEADING_2': return 'h2';\n            case 'HEADING_3': return 'h3';\n            case 'HEADING_4': return 'h4';\n            case 'HEADING_5': return 'h5';\n            case 'HEADING_6': return 'h6';\n            default: return null;\n        }\n    }\n\n    // Process paragraphs\n    function processParagraph(paragraphData) {\n        const paragraph = paragraphData.paragraph;\n        const elements = paragraph.elements || [];\n        const paragraphStyle = paragraph.paragraphStyle || {};\n        \n        const content = processTextElements(elements);\n        if (!content.trim()) return '';\n\n        // Check if this is a list item\n        if (handleList(paragraph)) {\n            return `<li>${content}</li>`;\n        } else {\n            // Close open lists if this is not a list item\n            while (openListTags.length > 0) {\n                html += `</${openListTags.pop()}>`;\n            }\n            currentListId = null;\n        }\n\n        // Check heading type\n        const headingTag = getHeadingTag(paragraphStyle.namedStyleType);\n        if (headingTag) {\n            let styles = [];\n            \n            // Alignment for headings\n            if (paragraphStyle.alignment && paragraphStyle.alignment !== 'START') {\n                const alignment = paragraphStyle.alignment.toLowerCase();\n                styles.push(`text-align: ${alignment}`);\n            }\n            \n            const styleAttr = styles.length > 0 ? ` style=\"${styles.join('; ')}\"` : '';\n            return `<${headingTag}${styleAttr}>${content}</${headingTag}>`;\n        }\n\n        // Regular paragraph\n        let styles = [];\n        \n        // Text alignment\n        if (paragraphStyle.alignment && paragraphStyle.alignment !== 'START') {\n            const alignment = paragraphStyle.alignment.toLowerCase();\n            styles.push(`text-align: ${alignment}`);\n        }\n\n        // Line spacing\n        if (paragraphStyle.lineSpacing && paragraphStyle.lineSpacing !== 100) {\n            styles.push(`line-height: ${paragraphStyle.lineSpacing / 100}`);\n        }\n\n        // Indentation\n        if (paragraphStyle.indentStart?.magnitude) {\n            styles.push(`margin-left: ${paragraphStyle.indentStart.magnitude}pt`);\n        }\n        \n        if (paragraphStyle.spaceAbove?.magnitude) {\n            styles.push(`margin-top: ${paragraphStyle.spaceAbove.magnitude}pt`);\n        }\n        \n        if (paragraphStyle.spaceBelow?.magnitude) {\n            styles.push(`margin-bottom: ${paragraphStyle.spaceBelow.magnitude}pt`);\n        }\n\n        const styleAttr = styles.length > 0 ? ` style=\"${styles.join('; ')}\"` : '';\n        return `<p${styleAttr}>${content}</p>`;\n    }\n\n    // Table processing\n    function processTable(tableData) {\n        const table = tableData.table;\n        let tableHtml = '<table style=\"border-collapse: collapse; width: 100%; margin: 16px 0;\">';\n        \n        for (let rowIndex = 0; rowIndex < table.tableRows.length; rowIndex++) {\n            const row = table.tableRows[rowIndex];\n            tableHtml += '<tr>';\n            \n            for (let cellIndex = 0; cellIndex < row.tableCells.length; cellIndex++) {\n                const cell = row.tableCells[cellIndex];\n                const cellContent = cell.content || [];\n                let cellHtml = '';\n                \n                // Process cell content\n                let tempListId = currentListId;\n                let tempOpenTags = [...openListTags];\n                let tempNestingLevel = currentNestingLevel;\n                currentListId = null;\n                openListTags = [];\n                currentNestingLevel = -1;\n                \n                for (const cellItem of cellContent) {\n                    if (cellItem.paragraph) {\n                        const paragraph = cellItem.paragraph;\n                        const elements = paragraph.elements || [];\n                        const content = processTextElements(elements);\n                        \n                        if (!content.trim()) continue;\n                        \n                        // Check if this is a list item inside table\n                        if (paragraph.bullet) {\n                            const bulletListId = paragraph.bullet.listId;\n                            const bulletNestingLevel = paragraph.bullet.nestingLevel || 0;\n                            \n                            if (currentListId !== bulletListId || currentNestingLevel !== bulletNestingLevel) {\n                                // If it's a completely different list, close all open lists\n                                if (currentListId !== bulletListId) {\n                                    while (openListTags.length > 0) {\n                                        cellHtml += `</${openListTags.pop()}>`;\n                                    }\n                                    currentNestingLevel = -1;\n                                }\n                                \n                                // Handle nesting level changes\n                                if (bulletNestingLevel > currentNestingLevel) {\n                                    // Going deeper - open new nested lists\n                                    while (currentNestingLevel < bulletNestingLevel) {\n                                        currentNestingLevel++;\n                                        const listTag = getListType(bulletListId, documentLists, currentNestingLevel);\n                                        cellHtml += `<${listTag}>`;\n                                        openListTags.push(listTag);\n                                    }\n                                } else if (bulletNestingLevel < currentNestingLevel) {\n                                    // Going up - close nested lists\n                                    while (currentNestingLevel > bulletNestingLevel) {\n                                        if (openListTags.length > 0) {\n                                            cellHtml += `</${openListTags.pop()}>`;\n                                        }\n                                        currentNestingLevel--;\n                                    }\n                                }\n                                \n                                currentListId = bulletListId;\n                                currentNestingLevel = bulletNestingLevel;\n                            }\n                            cellHtml += `<li>${safeToString(content)}</li>`;\n                        } else {\n                            // Close lists if this is not a list item\n                            while (openListTags.length > 0) {\n                                cellHtml += `</${openListTags.pop()}>`;\n                            }\n                            currentListId = null;\n                            \n                            // Determine heading type\n                            const headingTag = getHeadingTag(paragraph.paragraphStyle?.namedStyleType);\n                            if (headingTag) {\n                                cellHtml += `<${headingTag}>${safeToString(content)}</${headingTag}>`;\n                            } else {\n                                cellHtml += safeToString(content);\n                                if (cellIndex < row.tableCells.length - 1 || rowIndex < table.tableRows.length - 1) {\n                                    cellHtml += '<br>';\n                                }\n                            }\n                        }\n                    }\n                }\n                \n                // Close remaining lists in cell\n                while (openListTags.length > 0) {\n                    cellHtml += `</${openListTags.pop()}>`;\n                }\n                \n                // Restore list state\n                currentListId = tempListId;\n                openListTags = tempOpenTags;\n                currentNestingLevel = tempNestingLevel;\n                \n                // Remove extra <br> at the end\n                cellHtml = cellHtml.replace(/<br>$/, '');\n                \n                // Cell styles\n                const cellStyle = cell.tableCellStyle || {};\n                let cellStyles = ['border: 1px solid #ddd', 'padding: 8px', 'vertical-align: top'];\n                \n                // Content alignment\n                if (cellStyle.contentAlignment) {\n                    const alignment = cellStyle.contentAlignment.toLowerCase();\n                    if (alignment === 'center') {\n                        cellStyles.push('text-align: center');\n                    } else if (alignment === 'right') {\n                        cellStyles.push('text-align: right');\n                    }\n                }\n\n                // Indentation\n                if (cellStyle.paddingLeft?.magnitude) {\n                    cellStyles.push(`padding-left: ${cellStyle.paddingLeft.magnitude}pt`);\n                }\n                if (cellStyle.paddingRight?.magnitude) {\n                    cellStyles.push(`padding-right: ${cellStyle.paddingRight.magnitude}pt`);\n                }\n                if (cellStyle.paddingTop?.magnitude) {\n                    cellStyles.push(`padding-top: ${cellStyle.paddingTop.magnitude}pt`);\n                }\n                if (cellStyle.paddingBottom?.magnitude) {\n                    cellStyles.push(`padding-bottom: ${cellStyle.paddingBottom.magnitude}pt`);\n                }\n\n                // Background color\n                if (cellStyle.backgroundColor?.color?.rgbColor) {\n                    const bgColor = rgbToHex(cellStyle.backgroundColor.color.rgbColor);\n                    if (bgColor && bgColor !== '#ffffff') {\n                        cellStyles.push(`background-color: ${bgColor}`);\n                    }\n                }\n\n                const cellStyleAttr = ` style=\"${cellStyles.join('; ')}\"`;\n                \n                // Cell merging\n                const colspan = cellStyle.columnSpan > 1 ? ` colspan=\"${cellStyle.columnSpan}\"` : '';\n                const rowspan = cellStyle.rowSpan > 1 ? ` rowspan=\"${cellStyle.rowSpan}\"` : '';\n                \n                // Determine cell tag (th for headers)\n                const isHeader = rowIndex === 0 && cellHtml.includes('<strong>');\n                const cellTag = isHeader ? 'th' : 'td';\n                \n                tableHtml += `<${cellTag}${colspan}${rowspan}${cellStyleAttr}>${cellHtml || '&nbsp;'}</${cellTag}>`;\n            }\n            \n            tableHtml += '</tr>';\n        }\n        \n        tableHtml += '</table>';\n        return tableHtml;\n    }\n\n    // Main document structure processing\n    if (!Array.isArray(docStructure)) {\n        throw new Error('Document structure must be an array');\n    }\n\n    for (const item of docStructure) {\n        if (item.paragraph) {\n            const paragraphHtml = processParagraph(item);\n            html += paragraphHtml;\n        } else if (item.table) {\n            // Close open lists before table\n            while (openListTags.length > 0) {\n                html += `</${openListTags.pop()}>`;\n            }\n            currentListId = null;\n            currentNestingLevel = -1;\n            \n            html += processTable(item);\n        } else if (item.sectionBreak) {\n            // Section break processing\n            if (item.sectionBreak.sectionStyle?.sectionType === 'NEXT_PAGE') {\n                html += '<div style=\"page-break-before: always;\"></div>';\n            }\n        }\n    }\n\n    // Close all open lists at the end\n    while (openListTags.length > 0) {\n        html += `</${openListTags.pop()}>`;\n    }\n\n    return {\n        html: html,\n        images: images\n    };\n}\n\n// Function for basic HTML cleanup for WordPress\nfunction cleanHtmlForWordPress(html) {\n    return html\n        // Remove all inline styles\n        .replace(/\\s+style=\"[^\"]*\"/g, '')\n        // Remove data attributes\n        .replace(/\\s+data-[^=]*=\"[^\"]*\"/g, '')\n        // Simplify span tags without attributes\n        .replace(/<span>([^<]*)<\\/span>/g, '$1')\n        // Remove empty span tags\n        .replace(/<span[^>]*><\\/span>/g, '')\n        // Remove extra spaces\n        .replace(/\\s+/g, ' ')\n        // Remove spaces at the beginning and end of tags\n        .replace(/>\\s+</g, '><')\n        // Add rel=\"noopener\" to external links\n        .replace(/<a href=\"([^\"]*)\" target=\"_blank\"/g, '<a href=\"$1\" target=\"_blank\" rel=\"noopener\"');\n}\n\n// Function for ultra HTML cleanup for WordPress\nfunction ultraCleanHtmlForWordPress(html) {\n    return html\n        // Remove ALL attributes except href for links\n        .replace(/<([^a\\/][^>]*?)\\s+[^>]*?>/g, '<$1>')\n        .replace(/<\\/([^>]+)\\s+[^>]*?>/g, '</$1>')\n        // Restore links with href\n        .replace(/<a[^>]*href=\"([^\"]*)\"[^>]*>/g, '<a href=\"$1\">')\n        // Remove all span tags, keeping content\n        .replace(/<span[^>]*>/g, '')\n        .replace(/<\\/span>/g, '')\n        // Remove all div tags, keeping content\n        .replace(/<div[^>]*>/g, '')\n        .replace(/<\\/div>/g, '')\n        // Remove empty paragraphs\n        .replace(/<p[^>]*>\\s*<\\/p>/g, '')\n        // Remove extra spaces and line breaks\n        .replace(/\\s+/g, ' ')\n        .replace(/>\\s+</g, '><')\n        .trim();\n}\n\n// Function for maximum cleanup - only safe tags\nfunction wordPressSafeTagsOnly(html) {\n    // List of allowed WordPress tags\n    const allowedTags = [\n        'p', 'br', 'strong', 'em', 'b', 'i', 'u', 's', \n        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n        'ul', 'ol', 'li',\n        'table', 'tr', 'td', 'th', 'thead', 'tbody',\n        'a', 'img',\n        'blockquote', 'pre', 'code'\n    ];\n    \n    // Remove all disallowed tags\n    let cleaned = html.replace(/<\\/?([a-zA-Z0-9]+)[^>]*>/g, (match, tagName) => {\n        const tag = tagName.toLowerCase();\n        if (!allowedTags.includes(tag)) {\n            return ''; // Remove disallowed tag\n        }\n        \n        // For allowed tags remove attributes (except href for links)\n        if (tag === 'a' && match.includes('href=')) {\n            const href = match.match(/href=\"([^\"]*)\"/);\n            return href ? `<${match.startsWith('</') ? '/' : ''}a${href ? ` href=\"${href[1]}\"` : ''}>` : `<${match.startsWith('</') ? '/' : ''}a>`;\n        }\n        \n        return `<${match.startsWith('</') ? '/' : ''}${tag}>`;\n    });\n    \n    return cleaned\n        .replace(/\\s+/g, ' ')\n        .replace(/>\\s+</g, '><')\n        .trim();\n}\n\n// Function for proper table cell correction\nfunction fixTableCells(html) {\n    return html.replace(/<(td|th)>(.*?)<\\/\\1>/gs, (match, tag, content) => {\n        content = content.trim();\n        \n        if (!content) {\n            return `<${tag}><p></p></${tag}>`;\n        }\n        \n        if (content.startsWith('<p>')) {\n            return match;\n        }\n        \n        if (content.startsWith('<ul') || content.startsWith('<ol')) {\n            return `<${tag}>${content}</${tag}>`;\n        }\n        \n        return `<${tag}><p>${content}</p></${tag}>`;\n    });\n}\n\n// WordPress-compatible cleanup based on working example\nfunction wordPressCompatibleClean(html) {\n    let cleaned = html\n        // CRITICAL: Remove ALL HTML comments (ModSecurity blocks)\n        .replace(/<!--[\\s\\S]*?-->/g, '')\n        \n        // Remove all inline styles and attributes except basic ones\n        .replace(/\\s+style=\"[^\"]*\"/g, '')\n        .replace(/\\s+class=\"[^\"]*\"/g, '')\n        .replace(/\\s+id=\"[^\"]*\"/g, '')\n        .replace(/\\s+data-[^=]*=\"[^\"]*\"/g, '')\n        \n        // Simplify tables - only border=\"1\"\n        .replace(/<table[^>]*>/g, '<table border=\"1\">')\n        .replace(/<tr[^>]*>/g, '<tr>')\n        .replace(/<td[^>]*>/g, '<td>')\n        .replace(/<th[^>]*>/g, '<th>')\n        \n        // Replace <strong> with <b>, <em> with <i>\n        .replace(/<strong>/g, '<b>')\n        .replace(/<\\/strong>/g, '</b>')\n        .replace(/<em>/g, '<i>')\n        .replace(/<\\/em>/g, '</i>')\n        \n        // Remove span tags, keeping content\n        .replace(/<span[^>]*>/g, '')\n        .replace(/<\\/span>/g, '')\n        \n        // Remove potentially dangerous attributes (ModSecurity protection)\n        .replace(/\\s+onclick=\"[^\"]*\"/gi, '')\n        .replace(/\\s+onload=\"[^\"]*\"/gi, '')\n        .replace(/\\s+onerror=\"[^\"]*\"/gi, '')\n        .replace(/\\s+onmouseover=\"[^\"]*\"/gi, '')\n        .replace(/javascript:/gi, 'blocked:')\n        \n        // Add rel=\"noopener\" to links if not present\n        .replace(/<a href=\"([^\"]*)\" target=\"_blank\"(?![^>]*rel=)/g, '<a href=\"$1\" target=\"_blank\" rel=\"noopener\"')\n        \n        // Remove extra spaces (including newlines inside tags)\n        .replace(/ +/g, ' ')\n        .replace(/>\\s+</g, '><')\n        .replace(/\\n/g, '')\n        .trim();\n    \n    // CRITICAL: Fix table cell structure\n    return fixTableCells(cleaned);\n}\n\n// ===== CODE FOR USE IN n8n =====\n// Uncomment and adapt to your data:\n\ntry {\n    // Google Docs API response structure\n    const documentStructure = $json.body?.content;\n    const documentLists = $json.lists;\n    const inlineObjects = $json.inlineObjects;\n    \n    if (!Array.isArray(documentStructure)) {\n        throw new Error('Expected body.content array. Received: ' + JSON.stringify(Object.keys($json)));\n    }\n    \n    const result = convertGoogleDocsToHtml(documentStructure, documentLists, inlineObjects);\n    const html = result.html;\n    const images = result.images;\n    \n    // ===== CLEANUP LEVEL CONFIGURATION =====\n    // Change cleanLevel value to select cleanup level:\n    // 'none' - no cleanup (original HTML with styles)\n    // 'basic' - basic cleanup (removes styles but keeps structure)\n    // 'ultra' - ultra cleanup (removes all attributes and extra tags)\n    // 'safe' - only safe tags (maximum compatibility)\n    // 'wordpress' - WordPress-compatible (as in working example)\n    \n    const cleanLevel = 'wordpress'; // <-- CHANGE HERE\n    \n    let cleanHtml = html;\n    let cleanType = 'none';\n    \n    switch(cleanLevel) {\n        case 'basic':\n            cleanHtml = cleanHtmlForWordPress(html);\n            cleanType = 'basic';\n            break;\n        case 'ultra':\n            cleanHtml = ultraCleanHtmlForWordPress(html);\n            cleanType = 'ultra';\n            break;\n        case 'safe':\n            cleanHtml = wordPressSafeTagsOnly(html);\n            cleanType = 'safe';\n            break;\n        case 'wordpress':\n            cleanHtml = wordPressCompatibleClean(html);\n            cleanType = 'wordpress';\n            break;\n        default:\n            cleanHtml = html;\n            cleanType = 'none';\n    }\n    \n    return {\n        html: cleanHtml,           // Cleaned HTML (level depends on setting)\n        htmlRaw: html,            // Original HTML with all styles\n        htmlBasic: cleanHtmlForWordPress(html),      // Basic cleanup\n        htmlUltra: ultraCleanHtmlForWordPress(html), // Ultra cleanup\n        htmlSafe: wordPressSafeTagsOnly(html),       // Only safe tags\n        htmlWordPress: wordPressCompatibleClean(html), // WordPress-compatible\n        images: images,           // Array of images with URLs and metadata\n        success: true,\n        cleanLevel: cleanType,\n        elementsCount: documentStructure.length,\n        htmlLength: cleanHtml.length,\n        rawHtmlLength: html.length,\n        reductionPercent: Math.round((1 - cleanHtml.length / html.length) * 100)\n    };\n    \n} catch (error) {\n    return {\n        html: '',\n        success: false,\n        error: error.message,\n        receivedData: typeof $json.body,\n        availableKeys: $json ? Object.keys($json) : 'no $json'\n    };\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        352,
        0
      ],
      "id": "4c08d24a-4ea5-40a3-b7b6-522b3e0aa659",
      "name": "Convert Google DOCS to HTML"
    },
    {
      "parameters": {
        "url": "={{ $json.contentUri }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleApi",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "=data"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1232,
        192
      ],
      "id": "599c24aa-b904-47cd-9c1e-1bfeefd2c23a",
      "name": "Fetch image from Google DOCs",
      "credentials": {
        "googleApi": {
          "id": "q0RH8mKgQAahSr1L",
          "name": "Google Service Account account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://docs-staging.portaone.com/wp-json/wp/v2/media",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "=file",
              "inputDataFieldName": "data"
            },
            {
              "name": "title",
              "value": "={{ $json.title }}"
            },
            {
              "name": "caption",
              "value": "={{ $json.title }}"
            },
            {
              "name": "post",
              "value": "={{ $node['Post a document to WP'].json.id  }}"
            },
            {
              "name": "alt_text",
              "value": "={{ $json.alt }}"
            },
            {
              "name": "description",
              "value": "={{ $json.description }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1568,
        192
      ],
      "id": "4e2914ac-0090-4896-866b-66b37da9234f",
      "name": "Upload image to WP media",
      "credentials": {
        "httpBasicAuth": {
          "id": "rQKBdPROf1VPPiuJ",
          "name": "Wordpress API access"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ===== CODE FOR USE IN n8n =====\n// This runs in n8n Code Node after Merge\n\n// Get all input data\nconst inputs = $input.all();\n\n// If data comes as an array in a single element\nlet mergeData;\nif (inputs.length === 1 && Array.isArray(inputs[0])) {\n    mergeData = inputs[0];\n} else {\n    mergeData = inputs;\n}\n\n\n// First element - HTML data\nconst converterData = $node['Convert Google DOCS to HTML'];\n\n// n8n may wrap data in .json\nconst actualData = converterData.json || converterData;\nconst originalHtml = actualData.htmlWordPress || actualData.html;\nconst originalImages = actualData.images || [];\n\n\nif (!originalHtml) {\n    return { \n        error: 'No HTML found', \n        debug: { \n            converterData: Object.keys(converterData),\n            actualData: Object.keys(actualData),\n            hasJson: !!converterData.json\n        } \n    };\n}\n\n// Other elements - WordPress uploads\nconst wordPressUploads = mergeData.slice(1).map(item => item.json || item);\n\n// Create mapping table\nconst imageMapping = {};\n\nwordPressUploads.forEach(wpUpload => {\n    \n    const matchedImage = originalImages.find(img => {\n        const slug = wpUpload.slug || '';\n        const imageTitle = (img.title || img.alt || '').toLowerCase();\n        const cleanImageTitle = imageTitle\n            .replace(/[^\\w\\s\\-]/g, '')\n            .replace(/\\s+/g, '-')\n            .replace(/\\-+/g, '-')\n            .replace(/^-|-$/g, '');\n        \n        const match = slug.includes(cleanImageTitle) || cleanImageTitle.includes(slug);\n        return match;\n    });\n    \n    if (matchedImage) {\n        imageMapping[matchedImage.id] = {\n            sourceUrl: wpUpload.source_url,\n            alt: matchedImage.alt || matchedImage.title || '',\n            title: matchedImage.title || '',\n            wpId: wpUpload.id\n        };\n    } else {\n    }\n});\n\n\n// Replace placeholders\nlet updatedHtml = originalHtml;\nlet replacedCount = 0;\n\nconst placeholderRegex = /\\[\\[IMG:([^|]+)\\|([^\\]]*)\\]\\]/g;\n\nupdatedHtml = updatedHtml.replace(placeholderRegex, (match, imageId, altText) => {\n    const mapping = imageMapping[imageId];\n    \n    if (mapping) {\n        replacedCount++;\n        return `<img src=\"${mapping.sourceUrl}\" alt=\"${mapping.alt}\" title=\"${mapping.title}\" data-wp-id=\"${mapping.wpId}\" />`;\n    } else {\n        // Find original image to get title\n        const originalImage = originalImages.find(img => img.id === imageId);\n        const title = originalImage ? (originalImage.title || '') : '';\n        \n        // Check if this is help content\n        const webhookData = $node['Webhook'];\n        const isHelp = webhookData && webhookData.json && webhookData.json.body && webhookData.json.body.isHelp === true;\n        \n        // Add class only if this is help content\n        const className = isHelp ? ' class=\"visible-in-embedded-help\"' : '';\n        \n        return `<img src=\"\" alt=\"${altText}\" title=\"${title}\"${className} />`;\n    }\n});\n\nreturn {\n    html: updatedHtml,\n    success: true,\n    replacedCount: replacedCount,\n    totalPlaceholders: (originalHtml.match(placeholderRegex) || []).length,\n    message: `Successfully replaced ${replacedCount} image placeholders`\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        16
      ],
      "id": "14a33e7b-8ef2-4029-bd2d-611ef7de26b1",
      "name": "Replace image placeholders"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://docs-staging.portaone.com/wp-json/wp/v2/documentations/{{ $node['Post a document to WP'].json.id  }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"content\": {{ JSON.stringify($json.formattedHtml) }}\n} ",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1968,
        16
      ],
      "id": "1ec92d11-8bd7-403f-919e-3802d4f87d02",
      "name": "Update document in WP",
      "credentials": {
        "httpBasicAuth": {
          "id": "rQKBdPROf1VPPiuJ",
          "name": "Wordpress API access"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://docs-staging.portaone.com/wp-json/wp/v2/documentations",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"title\": \"{{ $node['Webhook'].json.body.title }}\",\n  \"slug\": \"{{ $node['Webhook'].json.body.slug }}\",\n  \"content\": {{ JSON.stringify($json.htmlWordPress) }},\n  \"status\": \"draft\"\n} ",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        560,
        0
      ],
      "id": "949b40da-3aa9-46f2-8c2d-636caa9165b7",
      "name": "Post a document to WP",
      "credentials": {
        "httpBasicAuth": {
          "id": "rQKBdPROf1VPPiuJ",
          "name": "Wordpress API access"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const item = $input.item;\nitem.binary.data.fileName = $json.fileName;\nreturn item;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1408,
        192
      ],
      "id": "5aec1f83-e293-4c6e-b425-52d11a79c482",
      "name": "Add file name"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=https://sheets.googleapis.com/v4/spreadsheets/{{ $node['Webhook'].json.body.spreadsheetId }}/values/{{ encodeURIComponent($node['Webhook'].json.body.sheetName) }}!F{{ $node['Webhook'].json.body.row }}:F{{ $node['Webhook'].json.body.row }}?valueInputOption=USER_ENTERED&includeValuesInResponse=true",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"range\": \"{{ $node['Webhook'].json.body.sheetName }}!F{{ $node['Webhook'].json.body.row }}:F{{ $node['Webhook'].json.body.row }}\",\n  \"majorDimension\": \"ROWS\",\n  \"values\": [[\"{{ $json.id ? 'Success' : 'Failed' }}\"]]\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2176,
        16
      ],
      "id": "f500cc28-4596-4b4e-af65-3f4760b1d51b",
      "name": "Post status to Google sheet",
      "credentials": {
        "googleApi": {
          "id": "q0RH8mKgQAahSr1L",
          "name": "Google Service Account account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Code Block Script\n// Formats unreadable HTML into a human-readable format with proper indentation\n\nconst inputHtml = $input.item.json.html; // Adjust based on your n8n input structure\n\nfunction formatHtml(html) {\n  const indentSize = 2;\n  \n  // Inline tags that should keep content on same line\n  const inlineTags = new Set(['a', 'b', 'i', 'u', 'strong', 'em', 'span', 'code', 'small', 'sup', 'sub']);\n  \n  // Self-closing tags\n  const selfClosingTags = new Set(['img', 'br', 'hr', 'input', 'meta', 'link', 'area', 'base', 'col']);\n  \n  // Block tags that should always be on separate lines\n  const blockTags = new Set(['div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'table', 'tr', 'td', 'th', 'ul', 'ol', 'thead', 'tbody']);\n  \n  // Find matching closing tag for an opening tag\n  function findMatchingClosingTag(html, startPos, tagName) {\n    let depth = 1;\n    let pos = startPos;\n    const openPattern = new RegExp(`<${tagName}[\\\\s>]`, 'gi');\n    const closePattern = new RegExp(`</${tagName}>`, 'gi');\n    \n    while (depth > 0 && pos < html.length) {\n      openPattern.lastIndex = pos;\n      closePattern.lastIndex = pos;\n      \n      const nextOpen = openPattern.exec(html);\n      const nextClose = closePattern.exec(html);\n      \n      if (!nextClose) return -1;\n      \n      if (nextOpen && nextOpen.index < nextClose.index) {\n        depth++;\n        pos = openPattern.lastIndex;\n      } else {\n        depth--;\n        if (depth === 0) {\n          return nextClose.index;\n        }\n        pos = closePattern.lastIndex;\n      }\n    }\n    return -1;\n  }\n  \n  // Check if content contains only text and inline tags\n  function hasOnlyInlineContent(content) {\n    let tempContent = content;\n    // Remove inline tags\n    for (const tag of inlineTags) {\n      tempContent = tempContent.replace(new RegExp(`<${tag}[^>]*>.*?</${tag}>`, 'gi'), '');\n      tempContent = tempContent.replace(new RegExp(`</?${tag}[^>]*>`, 'gi'), '');\n    }\n    // Check if any block tags remain\n    for (const tag of blockTags) {\n      if (tempContent.match(new RegExp(`<${tag}[\\\\s>]`, 'i'))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  function formatRecursive(html, indent) {\n    let result = '';\n    let pos = 0;\n    \n    while (pos < html.length) {\n      const tagStart = html.indexOf('<', pos);\n      \n      if (tagStart === -1) {\n        const text = html.substring(pos).trim();\n        if (text) {\n          result += ' '.repeat(indent) + text + '\\n';\n        }\n        break;\n      }\n      \n      // Add text before tag\n      if (tagStart > pos) {\n        const text = html.substring(pos, tagStart).trim();\n        if (text) {\n          result += ' '.repeat(indent) + text + '\\n';\n        }\n      }\n      \n      const tagEnd = html.indexOf('>', tagStart);\n      if (tagEnd === -1) break;\n      \n      const tag = html.substring(tagStart, tagEnd + 1);\n      const isClosingTag = tag.startsWith('</');\n      const tagNameMatch = tag.match(/<\\/?([a-z0-9]+)/i);\n      const tagName = tagNameMatch ? tagNameMatch[1].toLowerCase() : '';\n      const isSelfClosing = selfClosingTags.has(tagName) || tag.endsWith('/>');\n      \n      if (isClosingTag || isSelfClosing) {\n        result += ' '.repeat(indent) + tag + '\\n';\n        pos = tagEnd + 1;\n      } else {\n        // Opening tag - check if we should inline it\n        const closingPos = findMatchingClosingTag(html, tagEnd + 1, tagName);\n        \n        if (closingPos === -1) {\n          result += ' '.repeat(indent) + tag + '\\n';\n          pos = tagEnd + 1;\n          continue;\n        }\n        \n        const content = html.substring(tagEnd + 1, closingPos);\n        const closingTag = `</${tagName}>`;\n        const isHeader = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName);\n        const shouldInline = (inlineTags.has(tagName) || tagName === 'li' || isHeader) && hasOnlyInlineContent(content);\n        \n        if (shouldInline) {\n          // Keep everything on one line\n          const fullTag = tag + content + closingTag;\n          result += ' '.repeat(indent) + fullTag + '\\n';\n          pos = closingPos + closingTag.length;\n        } else {\n          // Format as block\n          result += ' '.repeat(indent) + tag + '\\n';\n          result += formatRecursive(content, indent + indentSize);\n          result += ' '.repeat(indent) + closingTag + '\\n';\n          pos = closingPos + closingTag.length;\n        }\n      }\n    }\n    \n    return result;\n  }\n  \n  return formatRecursive(html, 0).trim();\n}\n\n// Return formatted HTML\nreturn {\n  json: {\n    formattedHtml: formatHtml(inputHtml),\n    originalHtml: inputHtml\n  }\n};\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1776,
        16
      ],
      "id": "38573b2a-8721-463a-81ad-2efe5599ef65",
      "name": "Beautyify HTML"
    },
    {
      "parameters": {
        "jsCode": "// Check isHelp condition\nif ($node['Webhook'].json.body.isHelp !== true) {\n    return $input.all();\n  }\n  \n  // Function to wrap blocks in divs\n  function wrapBlocksInDivs(html) {\n    // Regular expression to find headers\n    const headerRegex = /(<h[1-6][^>]*>.*?<\\/h[1-6]>)/gi;\n    \n    // Split HTML by headers, keeping the headers themselves\n    const parts = html.split(headerRegex);\n    \n    const blocks = [];\n    let currentBlock = '';\n    \n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i].trim();\n      if (!part) continue;\n      \n      // Check if part is a header\n      if (headerRegex.test(part)) {\n        headerRegex.lastIndex = 0; // Reset index\n        \n        // If there is accumulated block, save it\n        if (currentBlock) {\n          blocks.push(`<div>\\n${currentBlock}\\n</div>`);\n        }\n        \n        // Start new block with header\n        currentBlock = part;\n      } else {\n        // Add content to current block\n        if (currentBlock) {\n          currentBlock += '\\n' + part;\n        } else {\n          // This is text at the beginning of document without header\n          currentBlock = part;\n        }\n      }\n    }\n    \n    // Add last block\n    if (currentBlock) {\n      blocks.push(`<div>\\n${currentBlock}\\n</div>`);\n    }\n    \n    return blocks.join('\\n');\n  }\n  \n  // Process each input data element\n  return $input.all().map(item => {\n    if (item.json.html) {\n      return {\n        json: {\n          ...item.json,\n          html: wrapBlocksInDivs(item.json.html)\n        }\n      };\n    }\n    return item;\n  });"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        16
      ],
      "id": "20a021d0-4147-486f-9153-769e7487e568",
      "name": "Process help"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Get a document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get a document": {
      "main": [
        [
          {
            "node": "Convert Google DOCS to HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Fetch image from Google DOCs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare images metadata": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Google DOCS to HTML": {
      "main": [
        [
          {
            "node": "Post a document to WP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch image from Google DOCs": {
      "main": [
        [
          {
            "node": "Add file name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload image to WP media": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Replace image placeholders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update document in WP": {
      "main": [
        [
          {
            "node": "Post status to Google sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post a document to WP": {
      "main": [
        [
          {
            "node": "Prepare images metadata",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add file name": {
      "main": [
        [
          {
            "node": "Upload image to WP media",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Replace image placeholders": {
      "main": [
        [
          {
            "node": "Process help",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Beautyify HTML": {
      "main": [
        [
          {
            "node": "Update document in WP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process help": {
      "main": [
        [
          {
            "node": "Beautyify HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "9dResy1Wkxyfiesi"
  },
  "versionId": "b8014450-1d1d-4746-bc60-6d6c650ea166",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "8d0d604ee3fa5812d8a83eb77a8e196e1e0ef5c26765eb3dc3671872b51bf04c"
  },
  "id": "9dResy1Wkxyfiesi",
  "tags": []
}