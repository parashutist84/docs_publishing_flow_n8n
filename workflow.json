{
  "name": "My workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "61193a00-dce7-4d57-bc8c-75789846daae",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -352,
        0
      ],
      "id": "7316c407-7031-4628-aab3-3424aa9ad945",
      "name": "Webhook",
      "webhookId": "61193a00-dce7-4d57-bc8c-75789846daae"
    },
    {
      "parameters": {
        "operation": "get",
        "documentURL": "={{ $json.body.docId }}",
        "simple": false
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        -176,
        0
      ],
      "id": "62281e2b-6335-416e-8f4a-471e0508300b",
      "name": "Get a document",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "9ppxGaLO1bYPI0rC",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.html }}",
        "options": {
          "systemMessage": "Ты получаешь html разметку, приведи её в удобочитаемый человеком вид, сделай отступы, что бы была видна структура документа. Ничего не комментируй, на выходе только html."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        848,
        496
      ],
      "id": "1a15f59a-f6d2-4dd8-bf44-1ab7b881a5d2",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5-nano",
          "mode": "list",
          "cachedResultName": "gpt-5-nano"
        },
        "options": {
          "responseFormat": "text"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        848,
        672
      ],
      "id": "0eb7fc17-97e4-476d-84c0-83f5cdd2b9ea",
      "name": "OpenAI Chat Model",
      "notesInFlow": false,
      "credentials": {
        "openAiApi": {
          "id": "0kJIIbgrruNvxWNz",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        688,
        176
      ],
      "id": "90165dae-3079-46f3-93b1-92584e01bf04",
      "name": "Loop Over Items"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        928,
        16
      ],
      "id": "62a3a27e-b1b5-48d5-a1b6-17bfbe06ca7b",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "console.log($node['Convert Google DOCS to HTML'].json)\nconst converterResult = $node['Convert Google DOCS to HTML'].json;\n\nconst html = converterResult.htmlWordPress;\nconst images = converterResult.images || [];\n\nreturn images.map((image, index) => ({\n  id: image.id,\n  contentUri: image.contentUri,\n  alt: image.alt,\n  title: image.title,\n  description: image.description,\n  \n  fileName: (() => {\n    const baseName = image.title || image.alt || image.description || `image-${image.id}`;\n    \n    let extension = '.jpg';\n    if (image.contentUri) {\n      const url = image.contentUri.toLowerCase();\n      if (url.includes('.png') || url.includes('png')) extension = '.png';\n      else if (url.includes('.gif') || url.includes('gif')) extension = '.gif';\n      else if (url.includes('.webp') || url.includes('webp')) extension = '.webp';\n      else if (url.includes('.svg') || url.includes('svg')) extension = '.svg';\n      else if (url.includes('.bmp') || url.includes('bmp')) extension = '.bmp';\n    }\n\n    const cleanName = baseName\n      .replace(/[^\\w\\s\\-]/g, '')\n      .replace(/\\s+/g, ' ')\n      .trim()\n      .replace(/\\s/g, '-')\n      .replace(/\\-+/g, '-')\n      .replace(/^-|-$/g, '')\n      .substring(0, 95)\n      .toLowerCase();\n    \n    return cleanName + extension;\n  })()\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        176
      ],
      "id": "c0ee2639-d01d-4a18-a46d-bd33c1cd76d5",
      "name": "Prepare images metadata"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Google Docs to HTML Converter for n8n\n * \n * USAGE INSTRUCTIONS FOR n8n:\n * \n * 1. Create a Code Node (Function Item)\n * 2. Copy this entire code into the JavaScript Code field\n * 3. At the end of the code add:\n *    \n *    const html = convertGoogleDocsToHtml($json.body);\n *    return { html: html };\n * \n * 4. Where $json.body is the document structure from Google Docs API\n */\n\nfunction convertGoogleDocsToHtml(docStructure, documentLists = null, inlineObjects = null) {\n    let html = '';\n    let currentListId = null;\n    let openListTags = [];\n    let currentNestingLevel = -1;\n    let images = []; // Collect images during processing\n\n    // RGB color processing\n    function rgbToHex(rgb) {\n        if (!rgb || typeof rgb !== 'object') return null;\n        const r = Math.round((rgb.red || 0) * 255);\n        const g = Math.round((rgb.green || 0) * 255);\n        const b = Math.round((rgb.blue || 0) * 255);\n        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n    }\n\n    // HTML escaping\n    function escapeHtml(text) {\n        const map = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#039;'\n        };\n        return text.replace(/[&<>\"']/g, function(m) { return map[m]; });\n    }\n\n    // Safe string conversion (solves [object Object] problem)\n    function safeToString(value) {\n        if (typeof value === 'string') {\n            return value;\n        }\n        if (value === null || value === undefined) {\n            return '';\n        }\n        if (typeof value === 'object') {\n            // If it's an object, try to get meaningful representation\n            if (value.toString && typeof value.toString === 'function' && value.toString !== Object.prototype.toString) {\n                return value.toString();\n            }\n            // As last resort return empty string instead of [object Object]\n            return '';\n        }\n        return String(value);\n    }\n\n    // Apply text styles\n    function applyTextStyles(content, textStyle) {\n        if (!textStyle) return escapeHtml(content);\n        \n        let styledContent = escapeHtml(content);\n        let styles = [];\n        let tags = [];\n\n        // Bold text\n        if (textStyle.bold) {\n            tags.push('strong');\n        }\n\n        // Italic\n        if (textStyle.italic) {\n            tags.push('em');\n        }\n\n        // Underline\n        if (textStyle.underline) {\n            tags.push('u');\n        }\n\n        // Strikethrough text\n        if (textStyle.strikethrough) {\n            tags.push('s');\n        }\n\n        // Text color\n        if (textStyle.foregroundColor?.color?.rgbColor) {\n            const color = rgbToHex(textStyle.foregroundColor.color.rgbColor);\n            if (color && color !== '#000000') {\n                styles.push(`color: ${color}`);\n            }\n        }\n\n        // Background color\n        if (textStyle.backgroundColor?.color?.rgbColor) {\n            const bgColor = rgbToHex(textStyle.backgroundColor.color.rgbColor);\n            if (bgColor && bgColor !== '#ffffff') {\n                styles.push(`background-color: ${bgColor}`);\n            }\n        }\n\n        // Font size\n        if (textStyle.fontSize?.magnitude) {\n            styles.push(`font-size: ${textStyle.fontSize.magnitude}pt`);\n        }\n\n        // Font family\n        if (textStyle.weightedFontFamily?.fontFamily) {\n            styles.push(`font-family: \"${textStyle.weightedFontFamily.fontFamily}\"`);\n        }\n\n        // Wrap in tags\n        for (const tag of tags) {\n            styledContent = `<${tag}>${styledContent}</${tag}>`;\n        }\n\n        // Apply inline styles\n        if (styles.length > 0) {\n            styledContent = `<span style=\"${styles.join('; ')}\">${styledContent}</span>`;\n        }\n\n        return styledContent;\n    }\n\n    // Link processing\n    function processLink(content, textStyle) {\n        if (textStyle?.link?.url) {\n            const styledContent = applyTextStyles(content, {...textStyle, link: undefined});\n            return `<a href=\"${escapeHtml(textStyle.link.url)}\" target=\"_blank\">${styledContent}</a>`;\n        }\n        return applyTextStyles(content, textStyle);\n    }\n\n    // Process paragraph elements\n    function processTextElements(elements) {\n        let result = '';\n        \n        for (const element of elements) {\n            if (element.textRun) {\n                let content = element.textRun.content;\n                \n                // Process line breaks\n                if (content.endsWith('\\n')) {\n                    content = content.slice(0, -1);\n                }\n                content = content.replace(/\\n/g, '<br>');\n                \n                if (content) {\n                    const linkResult = processLink(content, element.textRun.textStyle);\n                    result += safeToString(linkResult);\n                }\n            } else if (element.inlineObjectElement) {\n                // Process inline objects (images, etc.) - create placeholder\n                const inlineObjectId = element.inlineObjectElement.inlineObjectId;\n                \n                // Get image data from inlineObjects if available\n                let altText = '';\n                let contentUri = '';\n                if (inlineObjects && inlineObjects[inlineObjectId]) {\n                    const embeddedObject = inlineObjects[inlineObjectId].inlineObjectProperties?.embeddedObject;\n                    if (embeddedObject) {\n                        altText = embeddedObject.description || embeddedObject.title || '';\n                        contentUri = embeddedObject.imageProperties?.contentUri || '';\n                        \n                        // Add to images array if it's actually an image\n                        if (contentUri) {\n                            images.push({\n                                id: inlineObjectId,\n                                contentUri: contentUri,\n                                alt: altText,\n                                title: embeddedObject.title || '',\n                                description: embeddedObject.description || ''\n                            });\n                        }\n                    }\n                }\n                \n                // Create image placeholder\n                result += `[[IMG:${inlineObjectId}|${altText}]]`;\n            }\n        }\n        \n        return result;\n    }\n\n    // List processing with multi-level support\n    function handleList(paragraph) {\n        const bullet = paragraph.bullet;\n        if (!bullet) return null;\n\n        const listId = bullet.listId;\n        const nestingLevel = bullet.nestingLevel || 0;\n        \n        // Handle different list or different nesting level\n        if (currentListId !== listId || currentNestingLevel !== nestingLevel) {\n            \n            // If it's a completely different list, close all open lists\n            if (currentListId !== listId) {\n                while (openListTags.length > 0) {\n                    html += `</${openListTags.pop()}>`;\n                }\n                currentNestingLevel = -1;\n            }\n            \n            // Handle nesting level changes\n            if (nestingLevel > currentNestingLevel) {\n                // Going deeper - open new nested lists\n                while (currentNestingLevel < nestingLevel) {\n                    currentNestingLevel++;\n                    const listTag = getListType(listId, documentLists, currentNestingLevel);\n                    html += `<${listTag}>`;\n                    openListTags.push(listTag);\n                }\n            } else if (nestingLevel < currentNestingLevel) {\n                // Going up - close nested lists\n                while (currentNestingLevel > nestingLevel) {\n                    if (openListTags.length > 0) {\n                        html += `</${openListTags.pop()}>`;\n                    }\n                    currentNestingLevel--;\n                }\n            }\n            \n            currentListId = listId;\n            currentNestingLevel = nestingLevel;\n        }\n\n        return true;\n    }\n\n    // Determine if list is numbered (ol) or bulleted (ul) based on nesting level\n    function getListType(listId, lists, level = 0) {\n        if (!lists || !lists[listId]) {\n            return 'ul'; // Default to bulleted list\n        }\n        \n        const listProperties = lists[listId].listProperties;\n        if (!listProperties || !listProperties.nestingLevels) {\n            return 'ul';\n        }\n        \n        // Get the appropriate nesting level, fallback to level 0 if specific level not found\n        const nestingLevelIndex = Math.min(level, listProperties.nestingLevels.length - 1);\n        const nestingLevel = listProperties.nestingLevels[nestingLevelIndex];\n        \n        if (!nestingLevel) {\n            return 'ul';\n        }\n        \n        // Check for glyph symbol first - if present, it's always bulleted\n        if (nestingLevel.glyphSymbol) {\n            return 'ul';\n        }\n        \n        // Check glyphType - this is the most reliable indicator for numbered lists\n        if (nestingLevel.glyphType) {\n            switch (nestingLevel.glyphType) {\n                case 'DECIMAL':\n                case 'ALPHA':\n                case 'UPPER_ALPHA':\n                case 'LOWER_ALPHA':\n                case 'ROMAN':\n                case 'UPPER_ROMAN':\n                case 'LOWER_ROMAN':\n                    return 'ol';\n                case 'GLYPH_TYPE_UNSPECIFIED':\n                    return 'ul'; // Always bulleted for unspecified type\n                default:\n                    break;\n            }\n        }\n        \n        // Check for glyph format that indicates numbered list\n        if (nestingLevel.glyphFormat) {\n            const format = nestingLevel.glyphFormat;\n            // Numbered formats contain % followed by number\n            if (format.includes('%0') || format.includes('%1') || format.includes('%2')) {\n                return 'ol';\n            }\n        }\n        \n        \n        return 'ul'; // Default to bulleted\n    }\n\n    // Determine heading type\n    function getHeadingTag(namedStyleType) {\n        switch (namedStyleType) {\n            case 'HEADING_1': return 'h1';\n            case 'HEADING_2': return 'h2';\n            case 'HEADING_3': return 'h3';\n            case 'HEADING_4': return 'h4';\n            case 'HEADING_5': return 'h5';\n            case 'HEADING_6': return 'h6';\n            default: return null;\n        }\n    }\n\n    // Process paragraphs\n    function processParagraph(paragraphData) {\n        const paragraph = paragraphData.paragraph;\n        const elements = paragraph.elements || [];\n        const paragraphStyle = paragraph.paragraphStyle || {};\n        \n        const content = processTextElements(elements);\n        if (!content.trim()) return '';\n\n        // Check if this is a list item\n        if (handleList(paragraph)) {\n            return `<li>${content}</li>`;\n        } else {\n            // Close open lists if this is not a list item\n            while (openListTags.length > 0) {\n                html += `</${openListTags.pop()}>`;\n            }\n            currentListId = null;\n        }\n\n        // Check heading type\n        const headingTag = getHeadingTag(paragraphStyle.namedStyleType);\n        if (headingTag) {\n            let styles = [];\n            \n            // Alignment for headings\n            if (paragraphStyle.alignment && paragraphStyle.alignment !== 'START') {\n                const alignment = paragraphStyle.alignment.toLowerCase();\n                styles.push(`text-align: ${alignment}`);\n            }\n            \n            const styleAttr = styles.length > 0 ? ` style=\"${styles.join('; ')}\"` : '';\n            return `<${headingTag}${styleAttr}>${content}</${headingTag}>`;\n        }\n\n        // Regular paragraph\n        let styles = [];\n        \n        // Text alignment\n        if (paragraphStyle.alignment && paragraphStyle.alignment !== 'START') {\n            const alignment = paragraphStyle.alignment.toLowerCase();\n            styles.push(`text-align: ${alignment}`);\n        }\n\n        // Line spacing\n        if (paragraphStyle.lineSpacing && paragraphStyle.lineSpacing !== 100) {\n            styles.push(`line-height: ${paragraphStyle.lineSpacing / 100}`);\n        }\n\n        // Indentation\n        if (paragraphStyle.indentStart?.magnitude) {\n            styles.push(`margin-left: ${paragraphStyle.indentStart.magnitude}pt`);\n        }\n        \n        if (paragraphStyle.spaceAbove?.magnitude) {\n            styles.push(`margin-top: ${paragraphStyle.spaceAbove.magnitude}pt`);\n        }\n        \n        if (paragraphStyle.spaceBelow?.magnitude) {\n            styles.push(`margin-bottom: ${paragraphStyle.spaceBelow.magnitude}pt`);\n        }\n\n        const styleAttr = styles.length > 0 ? ` style=\"${styles.join('; ')}\"` : '';\n        return `<p${styleAttr}>${content}</p>`;\n    }\n\n    // Table processing\n    function processTable(tableData) {\n        const table = tableData.table;\n        let tableHtml = '<table style=\"border-collapse: collapse; width: 100%; margin: 16px 0;\">';\n        \n        for (let rowIndex = 0; rowIndex < table.tableRows.length; rowIndex++) {\n            const row = table.tableRows[rowIndex];\n            tableHtml += '<tr>';\n            \n            for (let cellIndex = 0; cellIndex < row.tableCells.length; cellIndex++) {\n                const cell = row.tableCells[cellIndex];\n                const cellContent = cell.content || [];\n                let cellHtml = '';\n                \n                // Process cell content\n                let tempListId = currentListId;\n                let tempOpenTags = [...openListTags];\n                let tempNestingLevel = currentNestingLevel;\n                currentListId = null;\n                openListTags = [];\n                currentNestingLevel = -1;\n                \n                for (const cellItem of cellContent) {\n                    if (cellItem.paragraph) {\n                        const paragraph = cellItem.paragraph;\n                        const elements = paragraph.elements || [];\n                        const content = processTextElements(elements);\n                        \n                        if (!content.trim()) continue;\n                        \n                        // Check if this is a list item inside table\n                        if (paragraph.bullet) {\n                            const bulletListId = paragraph.bullet.listId;\n                            const bulletNestingLevel = paragraph.bullet.nestingLevel || 0;\n                            \n                            if (currentListId !== bulletListId || currentNestingLevel !== bulletNestingLevel) {\n                                // If it's a completely different list, close all open lists\n                                if (currentListId !== bulletListId) {\n                                    while (openListTags.length > 0) {\n                                        cellHtml += `</${openListTags.pop()}>`;\n                                    }\n                                    currentNestingLevel = -1;\n                                }\n                                \n                                // Handle nesting level changes\n                                if (bulletNestingLevel > currentNestingLevel) {\n                                    // Going deeper - open new nested lists\n                                    while (currentNestingLevel < bulletNestingLevel) {\n                                        currentNestingLevel++;\n                                        const listTag = getListType(bulletListId, documentLists, currentNestingLevel);\n                                        cellHtml += `<${listTag}>`;\n                                        openListTags.push(listTag);\n                                    }\n                                } else if (bulletNestingLevel < currentNestingLevel) {\n                                    // Going up - close nested lists\n                                    while (currentNestingLevel > bulletNestingLevel) {\n                                        if (openListTags.length > 0) {\n                                            cellHtml += `</${openListTags.pop()}>`;\n                                        }\n                                        currentNestingLevel--;\n                                    }\n                                }\n                                \n                                currentListId = bulletListId;\n                                currentNestingLevel = bulletNestingLevel;\n                            }\n                            cellHtml += `<li>${safeToString(content)}</li>`;\n                        } else {\n                            // Close lists if this is not a list item\n                            while (openListTags.length > 0) {\n                                cellHtml += `</${openListTags.pop()}>`;\n                            }\n                            currentListId = null;\n                            \n                            // Determine heading type\n                            const headingTag = getHeadingTag(paragraph.paragraphStyle?.namedStyleType);\n                            if (headingTag) {\n                                cellHtml += `<${headingTag}>${safeToString(content)}</${headingTag}>`;\n                            } else {\n                                cellHtml += safeToString(content);\n                                if (cellIndex < row.tableCells.length - 1 || rowIndex < table.tableRows.length - 1) {\n                                    cellHtml += '<br>';\n                                }\n                            }\n                        }\n                    }\n                }\n                \n                // Close remaining lists in cell\n                while (openListTags.length > 0) {\n                    cellHtml += `</${openListTags.pop()}>`;\n                }\n                \n                // Restore list state\n                currentListId = tempListId;\n                openListTags = tempOpenTags;\n                currentNestingLevel = tempNestingLevel;\n                \n                // Remove extra <br> at the end\n                cellHtml = cellHtml.replace(/<br>$/, '');\n                \n                // Cell styles\n                const cellStyle = cell.tableCellStyle || {};\n                let cellStyles = ['border: 1px solid #ddd', 'padding: 8px', 'vertical-align: top'];\n                \n                // Content alignment\n                if (cellStyle.contentAlignment) {\n                    const alignment = cellStyle.contentAlignment.toLowerCase();\n                    if (alignment === 'center') {\n                        cellStyles.push('text-align: center');\n                    } else if (alignment === 'right') {\n                        cellStyles.push('text-align: right');\n                    }\n                }\n\n                // Indentation\n                if (cellStyle.paddingLeft?.magnitude) {\n                    cellStyles.push(`padding-left: ${cellStyle.paddingLeft.magnitude}pt`);\n                }\n                if (cellStyle.paddingRight?.magnitude) {\n                    cellStyles.push(`padding-right: ${cellStyle.paddingRight.magnitude}pt`);\n                }\n                if (cellStyle.paddingTop?.magnitude) {\n                    cellStyles.push(`padding-top: ${cellStyle.paddingTop.magnitude}pt`);\n                }\n                if (cellStyle.paddingBottom?.magnitude) {\n                    cellStyles.push(`padding-bottom: ${cellStyle.paddingBottom.magnitude}pt`);\n                }\n\n                // Background color\n                if (cellStyle.backgroundColor?.color?.rgbColor) {\n                    const bgColor = rgbToHex(cellStyle.backgroundColor.color.rgbColor);\n                    if (bgColor && bgColor !== '#ffffff') {\n                        cellStyles.push(`background-color: ${bgColor}`);\n                    }\n                }\n\n                const cellStyleAttr = ` style=\"${cellStyles.join('; ')}\"`;\n                \n                // Cell merging\n                const colspan = cellStyle.columnSpan > 1 ? ` colspan=\"${cellStyle.columnSpan}\"` : '';\n                const rowspan = cellStyle.rowSpan > 1 ? ` rowspan=\"${cellStyle.rowSpan}\"` : '';\n                \n                // Determine cell tag (th for headers)\n                const isHeader = rowIndex === 0 && cellHtml.includes('<strong>');\n                const cellTag = isHeader ? 'th' : 'td';\n                \n                tableHtml += `<${cellTag}${colspan}${rowspan}${cellStyleAttr}>${cellHtml || '&nbsp;'}</${cellTag}>`;\n            }\n            \n            tableHtml += '</tr>';\n        }\n        \n        tableHtml += '</table>';\n        return tableHtml;\n    }\n\n    // Main document structure processing\n    if (!Array.isArray(docStructure)) {\n        throw new Error('Document structure must be an array');\n    }\n\n    for (const item of docStructure) {\n        if (item.paragraph) {\n            const paragraphHtml = processParagraph(item);\n            html += paragraphHtml;\n        } else if (item.table) {\n            // Close open lists before table\n            while (openListTags.length > 0) {\n                html += `</${openListTags.pop()}>`;\n            }\n            currentListId = null;\n            currentNestingLevel = -1;\n            \n            html += processTable(item);\n        } else if (item.sectionBreak) {\n            // Section break processing\n            if (item.sectionBreak.sectionStyle?.sectionType === 'NEXT_PAGE') {\n                html += '<div style=\"page-break-before: always;\"></div>';\n            }\n        }\n    }\n\n    // Close all open lists at the end\n    while (openListTags.length > 0) {\n        html += `</${openListTags.pop()}>`;\n    }\n\n    return {\n        html: html,\n        images: images\n    };\n}\n\n// Function for basic HTML cleanup for WordPress\nfunction cleanHtmlForWordPress(html) {\n    return html\n        // Remove all inline styles\n        .replace(/\\s+style=\"[^\"]*\"/g, '')\n        // Remove data attributes\n        .replace(/\\s+data-[^=]*=\"[^\"]*\"/g, '')\n        // Simplify span tags without attributes\n        .replace(/<span>([^<]*)<\\/span>/g, '$1')\n        // Remove empty span tags\n        .replace(/<span[^>]*><\\/span>/g, '')\n        // Remove extra spaces\n        .replace(/\\s+/g, ' ')\n        // Remove spaces at the beginning and end of tags\n        .replace(/>\\s+</g, '><')\n        // Add rel=\"noopener\" to external links\n        .replace(/<a href=\"([^\"]*)\" target=\"_blank\"/g, '<a href=\"$1\" target=\"_blank\" rel=\"noopener\"');\n}\n\n// Function for ultra HTML cleanup for WordPress\nfunction ultraCleanHtmlForWordPress(html) {\n    return html\n        // Remove ALL attributes except href for links\n        .replace(/<([^a\\/][^>]*?)\\s+[^>]*?>/g, '<$1>')\n        .replace(/<\\/([^>]+)\\s+[^>]*?>/g, '</$1>')\n        // Restore links with href\n        .replace(/<a[^>]*href=\"([^\"]*)\"[^>]*>/g, '<a href=\"$1\">')\n        // Remove all span tags, keeping content\n        .replace(/<span[^>]*>/g, '')\n        .replace(/<\\/span>/g, '')\n        // Remove all div tags, keeping content\n        .replace(/<div[^>]*>/g, '')\n        .replace(/<\\/div>/g, '')\n        // Remove empty paragraphs\n        .replace(/<p[^>]*>\\s*<\\/p>/g, '')\n        // Remove extra spaces and line breaks\n        .replace(/\\s+/g, ' ')\n        .replace(/>\\s+</g, '><')\n        .trim();\n}\n\n// Function for maximum cleanup - only safe tags\nfunction wordPressSafeTagsOnly(html) {\n    // List of allowed WordPress tags\n    const allowedTags = [\n        'p', 'br', 'strong', 'em', 'b', 'i', 'u', 's', \n        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n        'ul', 'ol', 'li',\n        'table', 'tr', 'td', 'th', 'thead', 'tbody',\n        'a', 'img',\n        'blockquote', 'pre', 'code'\n    ];\n    \n    // Remove all disallowed tags\n    let cleaned = html.replace(/<\\/?([a-zA-Z0-9]+)[^>]*>/g, (match, tagName) => {\n        const tag = tagName.toLowerCase();\n        if (!allowedTags.includes(tag)) {\n            return ''; // Remove disallowed tag\n        }\n        \n        // For allowed tags remove attributes (except href for links)\n        if (tag === 'a' && match.includes('href=')) {\n            const href = match.match(/href=\"([^\"]*)\"/);\n            return href ? `<${match.startsWith('</') ? '/' : ''}a${href ? ` href=\"${href[1]}\"` : ''}>` : `<${match.startsWith('</') ? '/' : ''}a>`;\n        }\n        \n        return `<${match.startsWith('</') ? '/' : ''}${tag}>`;\n    });\n    \n    return cleaned\n        .replace(/\\s+/g, ' ')\n        .replace(/>\\s+</g, '><')\n        .trim();\n}\n\n// Function for proper table cell correction\nfunction fixTableCells(html) {\n    return html.replace(/<(td|th)>(.*?)<\\/\\1>/gs, (match, tag, content) => {\n        content = content.trim();\n        \n        if (!content) {\n            return `<${tag}><p>\\n</p></${tag}>`;\n        }\n        \n        if (content.startsWith('<p>')) {\n            return match;\n        }\n        \n        if (content.startsWith('<ul') || content.startsWith('<ol')) {\n            return `<${tag}>${content}</${tag}>`;\n        }\n        \n        return `<${tag}><p>${content}\\n</p></${tag}>`;\n    });\n}\n\n// WordPress-compatible cleanup based on working example\nfunction wordPressCompatibleClean(html) {\n    let cleaned = html\n        // CRITICAL: Remove ALL HTML comments (ModSecurity blocks)\n        .replace(/<!--[\\s\\S]*?-->/g, '')\n        \n        // Remove all inline styles and attributes except basic ones\n        .replace(/\\s+style=\"[^\"]*\"/g, '')\n        .replace(/\\s+class=\"[^\"]*\"/g, '')\n        .replace(/\\s+id=\"[^\"]*\"/g, '')\n        .replace(/\\s+data-[^=]*=\"[^\"]*\"/g, '')\n        \n        // Simplify tables - only border=\"1\"\n        .replace(/<table[^>]*>/g, '<table border=\"1\">')\n        .replace(/<tr[^>]*>/g, '<tr>')\n        .replace(/<td[^>]*>/g, '<td>')\n        .replace(/<th[^>]*>/g, '<th>')\n        \n        // Replace <strong> with <b>, <em> with <i>\n        .replace(/<strong>/g, '<b>')\n        .replace(/<\\/strong>/g, '</b>')\n        .replace(/<em>/g, '<i>')\n        .replace(/<\\/em>/g, '</i>')\n        \n        // Remove span tags, keeping content\n        .replace(/<span[^>]*>/g, '')\n        .replace(/<\\/span>/g, '')\n        \n        // Remove potentially dangerous attributes (ModSecurity protection)\n        .replace(/\\s+onclick=\"[^\"]*\"/gi, '')\n        .replace(/\\s+onload=\"[^\"]*\"/gi, '')\n        .replace(/\\s+onerror=\"[^\"]*\"/gi, '')\n        .replace(/\\s+onmouseover=\"[^\"]*\"/gi, '')\n        .replace(/javascript:/gi, 'blocked:')\n        \n        // Add rel=\"noopener\" to links if not present\n        .replace(/<a href=\"([^\"]*)\" target=\"_blank\"(?![^>]*rel=)/g, '<a href=\"$1\" target=\"_blank\" rel=\"noopener\"')\n        \n        // Add line breaks after closing tags\n        .replace(/<\\/(h[1-6]|p|li)>/g, '\\n</$1>')\n        \n        // Remove extra spaces but preserve line breaks\n        .replace(/ +/g, ' ')\n        .replace(/>\\s+</g, '><')\n        .trim();\n    \n    // CRITICAL: Fix table cell structure\n    return fixTableCells(cleaned);\n}\n\n// ===== CODE FOR USE IN n8n =====\n// Uncomment and adapt to your data:\n\ntry {\n    // IMPORTANT: Document structure is in body.content, not in body!\n    let documentStructure;\n    let documentLists = null;\n    let inlineObjects = null;\n    \n    // Check different data structure variants\n    if ($json.body && $json.body.content) {\n        // Standard Google Docs API response\n        documentStructure = $json.body.content;\n        documentLists = $json.lists || $json.body.lists;\n        inlineObjects = $json.inlineObjects || $json.body.inlineObjects;\n    } else if ($json.content) {\n        // If content is at top level\n        documentStructure = $json.content;\n        documentLists = $json.lists;\n        inlineObjects = $json.inlineObjects;\n    } else if (Array.isArray($json.body)) {\n        // If body is already an array\n        documentStructure = $json.body;\n        documentLists = $json.lists;\n        inlineObjects = $json.inlineObjects;\n    } else if ($json.body && typeof $json.body === 'object') {\n        // Try to find content in body object\n        const bodyKeys = Object.keys($json.body);\n        const contentKey = bodyKeys.find(key => Array.isArray($json.body[key]));\n        if (contentKey) {\n            documentStructure = $json.body[contentKey];\n        }\n        documentLists = $json.lists || $json.body.lists;\n        inlineObjects = $json.inlineObjects || $json.body.inlineObjects;\n    }\n    \n    if (!documentStructure) {\n        throw new Error('No document structure found. Expected array in body.content or similar field. Received: ' + JSON.stringify(Object.keys($json)));\n    }\n    \n    if (!Array.isArray(documentStructure)) {\n        throw new Error('Document structure must be an array. Received: ' + typeof documentStructure);\n    }\n    \n    const result = convertGoogleDocsToHtml(documentStructure, documentLists, inlineObjects);\n    const html = result.html;\n    const images = result.images;\n    \n    // ===== CLEANUP LEVEL CONFIGURATION =====\n    // Change cleanLevel value to select cleanup level:\n    // 'none' - no cleanup (original HTML with styles)\n    // 'basic' - basic cleanup (removes styles but keeps structure)\n    // 'ultra' - ultra cleanup (removes all attributes and extra tags)\n    // 'safe' - only safe tags (maximum compatibility)\n    // 'wordpress' - WordPress-compatible (as in working example)\n    \n    const cleanLevel = 'wordpress'; // <-- CHANGE HERE\n    \n    let cleanHtml = html;\n    let cleanType = 'none';\n    \n    switch(cleanLevel) {\n        case 'basic':\n            cleanHtml = cleanHtmlForWordPress(html);\n            cleanType = 'basic';\n            break;\n        case 'ultra':\n            cleanHtml = ultraCleanHtmlForWordPress(html);\n            cleanType = 'ultra';\n            break;\n        case 'safe':\n            cleanHtml = wordPressSafeTagsOnly(html);\n            cleanType = 'safe';\n            break;\n        case 'wordpress':\n            cleanHtml = wordPressCompatibleClean(html);\n            cleanType = 'wordpress';\n            break;\n        default:\n            cleanHtml = html;\n            cleanType = 'none';\n    }\n    \n    return {\n        html: cleanHtml,           // Cleaned HTML (level depends on setting)\n        htmlRaw: html,            // Original HTML with all styles\n        htmlBasic: cleanHtmlForWordPress(html),      // Basic cleanup\n        htmlUltra: ultraCleanHtmlForWordPress(html), // Ultra cleanup\n        htmlSafe: wordPressSafeTagsOnly(html),       // Only safe tags\n        htmlWordPress: wordPressCompatibleClean(html), // WordPress-compatible\n        images: images,           // Array of images with URLs and metadata\n        success: true,\n        cleanLevel: cleanType,\n        elementsCount: documentStructure.length,\n        htmlLength: cleanHtml.length,\n        rawHtmlLength: html.length,\n        reductionPercent: Math.round((1 - cleanHtml.length / html.length) * 100)\n    };\n    \n} catch (error) {\n    return {\n        html: '',\n        success: false,\n        error: error.message,\n        receivedData: typeof $json.body,\n        availableKeys: $json ? Object.keys($json) : 'no $json'\n    };\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        0
      ],
      "id": "6c6a558a-2af7-4387-b0f0-13cd1d283bec",
      "name": "Convert Google DOCS to HTML"
    },
    {
      "parameters": {
        "url": "={{ $json.contentUri }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleDocsOAuth2Api",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file",
              "outputPropertyName": "=data"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        880,
        192
      ],
      "id": "b659ec92-a77f-4075-83d0-e256c7f1957b",
      "name": "Fetch image from Google DOCs",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "9ppxGaLO1bYPI0rC",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://docs-staging.portaone.com/wp-json/wp/v2/media",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "=file",
              "inputDataFieldName": "data"
            },
            {
              "name": "title",
              "value": "={{ $json.title }}"
            },
            {
              "name": "caption",
              "value": "={{ $json.title }}"
            },
            {
              "name": "post",
              "value": "={{ $node['Post a document to WP'].json.id  }}"
            },
            {
              "name": "alt_text",
              "value": "={{ $json.alt }}"
            },
            {
              "name": "description",
              "value": "={{ $json.description }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1216,
        192
      ],
      "id": "41946827-0d79-4605-99bb-b01f52851410",
      "name": "Upload image to WP media",
      "credentials": {
        "httpBasicAuth": {
          "id": "ax0qsGYDn9f41U4D",
          "name": "Unnamed credential"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * Replace Image Placeholders in HTML\n * \n * This function takes the Merge output and replaces image placeholders\n * with actual <img> tags using WordPress URLs\n */\n\nfunction replacePlaceholders(mergeData) {\n    console.log('Processing merge data with length:', mergeData.length);\n    \n    // Если массив содержит только один элемент, это может быть объединенные данные\n    if (mergeData.length === 1 && mergeData[0].html) {\n        // Единичный объект с HTML - возможно, WordPress загрузки не прошли\n        const data = mergeData[0];\n        const originalHtml = data.htmlWordPress || data.html;\n        const originalImages = data.images || [];\n        \n        console.log('Single object mode - no WordPress uploads found');\n        console.log('HTML length:', originalHtml ? originalHtml.length : 'undefined');\n        console.log('Images count:', originalImages.length);\n        \n        // Если нет WordPress загрузок, просто удаляем плейсхолдеры или оставляем как есть\n        if (!originalHtml) {\n            throw new Error('No HTML content found in data');\n        }\n        \n        // Заменяем плейсхолдеры на заглушки\n        const placeholderRegex = /\\[\\[IMG:([^|]+)\\|([^\\]]*)\\]\\]/g;\n        const updatedHtml = originalHtml.replace(placeholderRegex, (match, imageId, altText) => {\n            return `<!-- Image placeholder: ${imageId} - ${altText} -->`;\n        });\n        \n        return {\n            html: updatedHtml,\n            success: true,\n            replacedCount: 0,\n            totalPlaceholders: (originalHtml.match(placeholderRegex) || []).length,\n            message: 'No WordPress uploads found - placeholders converted to comments'\n        };\n    }\n    \n    // Первый элемент - данные из конвертера (HTML + metadata)\n    const converterData = mergeData[0];\n    const originalHtml = converterData.htmlWordPress || converterData.html;\n    const originalImages = converterData.images || [];\n    \n    console.log('Converter data keys:', Object.keys(converterData));\n    console.log('HTML found:', !!originalHtml);\n    console.log('HTML type:', typeof originalHtml);\n    console.log('HTML length:', originalHtml ? originalHtml.length : 'N/A');\n    console.log('Images found:', originalImages.length);\n    \n    if (!originalHtml) {\n        throw new Error('No HTML content found in converter data');\n    }\n    \n    console.log('Multi-element mode - processing WordPress uploads');\n    console.log('HTML length:', originalHtml.length);\n    console.log('Original images:', originalImages.length);\n    \n    // Остальные элементы - результаты загрузки в WordPress\n    const wordPressUploads = mergeData.slice(1);\n    \n    // Создаем карту соответствий: originalId -> WordPress data\n    const imageMapping = {};\n    \n    wordPressUploads.forEach((wpUpload, index) => {\n        console.log(`Processing WordPress upload ${index}:`, {\n            id: wpUpload.id,\n            slug: wpUpload.slug,\n            title: wpUpload.title?.rendered || wpUpload.title?.raw,\n            source_url: wpUpload.source_url\n        });\n        \n        // Ищем соответствующее изображение в originalImages по названию\n        const matchedImage = originalImages.find(img => {\n            // Сопоставляем по slug и title\n            const slug = wpUpload.slug || '';\n            const wpTitle = (wpUpload.title?.rendered || wpUpload.title?.raw || '').toLowerCase();\n            const imageTitle = (img.title || img.alt || '').toLowerCase();\n            \n            console.log(`Comparing: \"${imageTitle}\" with slug \"${slug}\" and title \"${wpTitle}\"`);\n            \n            // Проверяем разные варианты сопоставления\n            const cleanImageTitle = imageTitle\n                .replace(/[^\\w\\s\\-]/g, '')\n                .replace(/\\s+/g, '-')\n                .replace(/\\-+/g, '-')\n                .replace(/^-|-$/g, '');\n            \n            const isSlugMatch = slug.includes(cleanImageTitle) || cleanImageTitle.includes(slug);\n            const isTitleMatch = wpTitle.includes(imageTitle) || imageTitle.includes(wpTitle);\n            \n            console.log(`  Clean title: \"${cleanImageTitle}\", slug match: ${isSlugMatch}, title match: ${isTitleMatch}`);\n            \n            return isSlugMatch || isTitleMatch;\n        });\n        \n        if (matchedImage) {\n            console.log(`✅ Matched image: ${matchedImage.id} -> ${wpUpload.id}`);\n            imageMapping[matchedImage.id] = {\n                id: matchedImage.id,\n                wpId: wpUpload.id,\n                sourceUrl: wpUpload.source_url,\n                alt: matchedImage.alt || matchedImage.description || matchedImage.title || '',\n                title: matchedImage.title || '',\n                originalUrl: matchedImage.contentUri\n            };\n        } else {\n            console.log(`❌ No match found for WordPress upload: ${wpUpload.slug}`);\n        }\n    });\n    \n    // Заменяем плейсхолдеры в HTML\n    let updatedHtml = originalHtml;\n    let replacedCount = 0;\n    const replacements = [];\n    \n    // Ищем все плейсхолдеры [[IMG:id|alt]]\n    const placeholderRegex = /\\[\\[IMG:([^|]+)\\|([^\\]]*)\\]\\]/g;\n    \n    updatedHtml = updatedHtml.replace(placeholderRegex, (match, imageId, altText) => {\n        const mapping = imageMapping[imageId];\n        \n        if (mapping) {\n            replacedCount++;\n            replacements.push({\n                placeholder: match,\n                imageId: imageId,\n                wpUrl: mapping.sourceUrl,\n                wpId: mapping.wpId\n            });\n            \n            // Создаем img тег\n            const imgTag = `<img src=\"${mapping.sourceUrl}\" alt=\"${mapping.alt}\" title=\"${mapping.title}\" data-wp-id=\"${mapping.wpId}\" />`;\n            return imgTag;\n        } else {\n            // Если соответствие не найдено, оставляем плейсхолдер или заменяем на заглушку\n            console.warn(`No WordPress upload found for image: ${imageId}`);\n            return `<!-- Image not found: ${imageId} -->`;\n        }\n    });\n    \n    return {\n        html: updatedHtml,\n        success: true,\n        replacedCount: replacedCount,\n        totalPlaceholders: (originalHtml.match(placeholderRegex) || []).length,\n        totalWordPressUploads: wordPressUploads.length,\n        imageMapping: Object.values(imageMapping),\n        replacements: replacements,\n        message: `Successfully replaced ${replacedCount} image placeholders`\n    };\n}\n\n// ===== CODE FOR USE IN n8n =====\n// This runs in n8n Code Node after Merge\n\n// Получаем все входящие данные\nconst inputs = $input.all();\nconsole.log('Total inputs:', inputs.length);\n\n// Если данные приходят как массив в одном элементе\nlet mergeData;\nif (inputs.length === 1 && Array.isArray(inputs[0])) {\n    mergeData = inputs[0];\n} else {\n    mergeData = inputs;\n}\n\nconsole.log('Processing data length:', mergeData.length);\n\n// Первый элемент - HTML данные\nconst converterData = $node['Convert Google DOCS to HTML'];\n\n// n8n может оборачивать данные в .json\nconst actualData = converterData.json || converterData;\nconst originalHtml = actualData.htmlWordPress || actualData.html;\nconst originalImages = actualData.images || [];\n\nconsole.log('Converter data keys:', Object.keys(converterData));\nconsole.log('Actual data keys:', Object.keys(actualData));\nconsole.log('HTML found:', !!originalHtml);\nconsole.log('Images found:', originalImages.length);\n\nif (!originalHtml) {\n    return { \n        error: 'No HTML found', \n        debug: { \n            converterData: Object.keys(converterData),\n            actualData: Object.keys(actualData),\n            hasJson: !!converterData.json\n        } \n    };\n}\n\n// Остальные элементы - WordPress загрузки\nconst wordPressUploads = mergeData.slice(1).map(item => item.json || item);\nconsole.log('WordPress uploads:', wordPressUploads.length);\n\n// Создаем карту соответствий\nconst imageMapping = {};\n\nwordPressUploads.forEach(wpUpload => {\n    console.log('Processing WP upload:', { id: wpUpload.id, slug: wpUpload.slug });\n    \n    const matchedImage = originalImages.find(img => {\n        const slug = wpUpload.slug || '';\n        const imageTitle = (img.title || img.alt || '').toLowerCase();\n        const cleanImageTitle = imageTitle\n            .replace(/[^\\w\\s\\-]/g, '')\n            .replace(/\\s+/g, '-')\n            .replace(/\\-+/g, '-')\n            .replace(/^-|-$/g, '');\n        \n        const match = slug.includes(cleanImageTitle) || cleanImageTitle.includes(slug);\n        console.log(`  Comparing \"${imageTitle}\" -> \"${cleanImageTitle}\" with \"${slug}\": ${match}`);\n        return match;\n    });\n    \n    if (matchedImage) {\n        console.log(`  ✅ Matched: ${matchedImage.id} -> ${wpUpload.id}`);\n        imageMapping[matchedImage.id] = {\n            sourceUrl: wpUpload.source_url,\n            alt: matchedImage.alt || matchedImage.title || '',\n            title: matchedImage.title || '',\n            wpId: wpUpload.id\n        };\n    } else {\n        console.log(`  ❌ No match found for ${wpUpload.slug}`);\n    }\n});\n\nconsole.log('Image mappings found:', Object.keys(imageMapping).length);\n\n// Заменяем плейсхолдеры\nlet updatedHtml = originalHtml;\nlet replacedCount = 0;\n\nconst placeholderRegex = /\\[\\[IMG:([^|]+)\\|([^\\]]*)\\]\\]/g;\n\nupdatedHtml = updatedHtml.replace(placeholderRegex, (match, imageId, altText) => {\n    const mapping = imageMapping[imageId];\n    \n    if (mapping) {\n        replacedCount++;\n        console.log(`✅ Replaced: ${imageId}`);\n        return `<img src=\"${mapping.sourceUrl}\" alt=\"${mapping.alt}\" title=\"${mapping.title}\" data-wp-id=\"${mapping.wpId}\" />`;\n    } else {\n        console.log(`❌ No mapping for: ${imageId}`);\n        return `<!-- Image not found: ${imageId} -->`;\n    }\n});\n\nreturn {\n    html: updatedHtml,\n    success: true,\n    replacedCount: replacedCount,\n    totalPlaceholders: (originalHtml.match(placeholderRegex) || []).length,\n    message: `Successfully replaced ${replacedCount} image placeholders`\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        16
      ],
      "id": "39713ab2-5df9-421e-8f76-afd20d91c06f",
      "name": "Replace image placeholders"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://docs-staging.portaone.com/wp-json/wp/v2/documentations/{{ $node['Post a document to WP'].json.id  }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"content\": {{ JSON.stringify($json.output) }}\n} ",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1264,
        16
      ],
      "id": "3331d8b8-7589-4481-82f5-10aab8371187",
      "name": "Update document in WP",
      "credentials": {
        "wordpressApi": {
          "id": "qDG8E7WBH2cfrJQT",
          "name": "Wordpress account"
        },
        "httpBasicAuth": {
          "id": "ax0qsGYDn9f41U4D",
          "name": "Unnamed credential"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://docs-staging.portaone.com/wp-json/wp/v2/documentations",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"title\": \"{{ $node['Webhook'].json.body.title }}\",\n  \"slug\": \"{{ $node['Webhook'].json.body.slug }}\",\n  \"content\": {{ JSON.stringify($json.htmlWordPress) }},\n  \"status\": \"draft\"\n} ",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        208,
        0
      ],
      "id": "2edf97f7-2848-4368-97e9-a9963d5ee5a9",
      "name": "Post a document to WP",
      "credentials": {
        "wordpressApi": {
          "id": "qDG8E7WBH2cfrJQT",
          "name": "Wordpress account"
        },
        "httpBasicAuth": {
          "id": "ax0qsGYDn9f41U4D",
          "name": "Unnamed credential"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const item = $input.item;\nitem.binary.data.fileName = $json.fileName;\nreturn item;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1056,
        192
      ],
      "id": "621c9167-140c-4f40-999e-734ae01ca0de",
      "name": "Add file name"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=https://sheets.googleapis.com/v4/spreadsheets/{{ $node['Webhook'].json.body.spreadsheetId }}/values/{{ encodeURIComponent($node['Webhook'].json.body.sheetName) }}!F{{ $node['Webhook'].json.body.row }}:F{{ $node['Webhook'].json.body.row }}?valueInputOption=USER_ENTERED&includeValuesInResponse=true",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleSheetsOAuth2Api",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"range\": \"{{ $node['Webhook'].json.body.sheetName }}!F{{ $node['Webhook'].json.body.row }}:F{{ $node['Webhook'].json.body.row }}\",\n  \"majorDimension\": \"ROWS\",\n  \"values\": [[\"{{ $json.id ? 'Success' : 'Failed' }}\"]]\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1472,
        16
      ],
      "id": "cdf06abb-1aa2-4781-91c5-de699d83d6c1",
      "name": "Post status to Google sheet",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "Iqlvt27WfRX8NfPW",
          "name": "Google Sheets account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Get a document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get a document": {
      "main": [
        [
          {
            "node": "Convert Google DOCS to HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        []
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Fetch image from Google DOCs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare images metadata": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Google DOCS to HTML": {
      "main": [
        [
          {
            "node": "Post a document to WP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch image from Google DOCs": {
      "main": [
        [
          {
            "node": "Add file name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload image to WP media": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Replace image placeholders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Replace image placeholders": {
      "main": [
        []
      ]
    },
    "Update document in WP": {
      "main": [
        [
          {
            "node": "Post status to Google sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post a document to WP": {
      "main": [
        [
          {
            "node": "Prepare images metadata",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add file name": {
      "main": [
        [
          {
            "node": "Upload image to WP media",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "f7a3d669-0c5a-4353-ae04-7b028a62184a",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "51ea8f415ad4de7c224ab7f86ed0de55dbb0848eac9173f964f9fc7b5000ca56"
  },
  "id": "jtEIJ5N6tlCH3Sjk",
  "tags": []
}